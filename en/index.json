[{"categories":["Multi-threading"],"content":"C++ Multi-threading coding\"","date":"2025-04-22","objectID":"/en/multhread/","tags":["C++","Multi-threading"],"title":"Multi-threading","uri":"/en/multhread/"},{"categories":["Multi-threading"],"content":"Multi-threading why do we need to use multi thread ","date":"2025-04-22","objectID":"/en/multhread/:1:0","tags":["C++","Multi-threading"],"title":"Multi-threading","uri":"/en/multhread/"},{"categories":["Data Structure and Algorithm"],"content":"Newton-Raphson method method for solving approximate solutions of equations.","date":"2023-11-01","objectID":"/en/newton-raphson/","tags":["Numerical Analysis","Algorithm"],"title":"Newton-Raphson method","uri":"/en/newton-raphson/"},{"categories":["Data Structure and Algorithm"],"content":"Introduction The Newton iteration method, as the name suggests, is a method proposed by Newton for solving approximate solutions to equations. This article mainly introduces the principle of Newton’s iterative method and its application in solving square roots. ","date":"2023-11-01","objectID":"/en/newton-raphson/:1:0","tags":["Numerical Analysis","Algorithm"],"title":"Newton-Raphson method","uri":"/en/newton-raphson/"},{"categories":["Data Structure and Algorithm"],"content":"Theory Assuming an approximate solution of equation $f(x)=0$ is $x_k$，the first-order Taylor expansion of $f(x)$ in $x_k$ is $f(x)=f(x_k)+f'(x_k)(x-x_k)+o(x)$，so $f(x_k)+f'(x_k)(x-x_k) \\approx f(x)$. In order to obtain $f(x_k)+f'(x_k)(x-x_k)=0$，obtain a new approximate solution set to $x_{k+1}$, assum： \\begin{equation} x_{k+1}=x_k-\\frac{f(x_k)}{f'(x_k)} \\end{equation} The above equation is the Newton iterative formula. ","date":"2023-11-01","objectID":"/en/newton-raphson/:2:0","tags":["Numerical Analysis","Algorithm"],"title":"Newton-Raphson method","uri":"/en/newton-raphson/"},{"categories":["Data Structure and Algorithm"],"content":"Solve square root Assuming $f(x)=x^2-n=0$，The solution to this equation is $\\sqrt{n}$. According to Newton’s iterative formula, we can obtain the following iterative formula: \\begin{equation} x_{k+1}=x_k-\\frac{x_{k}^2-n}{2x_k}=\\frac{x_k+\\frac{n}{x_k}}{2} \\end{equation} The code is as follows： double newton_sqrt(double n){ const double eps = 1e-15;//precision double x = 1; while(true){ double nx = (x+n/x)/2; if(abs(nx-x)\u003ceps) break; x=nx; } } Of course, we can also solve through the dichotomy method. The code is as follows: double dichotomy_sqrt(double n){ double left=0; double right=max(1,n); while(abs(left-right)\u003e1e-5){ x=(left+right)/2 if(x*x\u003en) right=x; else left=x; } return x; } The algorithm complexity is $O(log_{2}n)$. ","date":"2023-11-01","objectID":"/en/newton-raphson/:3:0","tags":["Numerical Analysis","Algorithm"],"title":"Newton-Raphson method","uri":"/en/newton-raphson/"},{"categories":["Data Structure and Algorithm"],"content":"Reference oi-wiki Newton citizendium Newton’s method ","date":"2023-11-01","objectID":"/en/newton-raphson/:4:0","tags":["Numerical Analysis","Algorithm"],"title":"Newton-Raphson method","uri":"/en/newton-raphson/"},{"categories":["Data Structure and Algorithm"],"content":"Detailed explanation of Recursion Algorithm.","date":"2023-02-08","objectID":"/en/recursion/","tags":["Recursion","Algorithm"],"title":"Recursion Algorithm","uri":"/en/recursion/"},{"categories":["Data Structure and Algorithm"],"content":"Introduction Recursive algorithm is an algorithm which directly or indirectly calls its own functions or methods. Simply put, it is the call of the program itself. The essence of recursive algorithm is to decompose the problem into smaller sub-problems, and then recursively call methods to represent the solution of the problem. ","date":"2023-02-08","objectID":"/en/recursion/:1:0","tags":["Recursion","Algorithm"],"title":"Recursion Algorithm","uri":"/en/recursion/"},{"categories":["Data Structure and Algorithm"],"content":"Characteristics of Recursive Algorithm Recursive algorithm can simplify complex problems and make the code more concise. However, in the process of recursive call, the system opens up a stack for storing the return points and local quantities of each layer. Too many times of recursion can easily cause stack overflow and low efficiency, so it is generally not recommended to use recursive algorithm to design programs. ","date":"2023-02-08","objectID":"/en/recursion/:2:0","tags":["Recursion","Algorithm"],"title":"Recursion Algorithm","uri":"/en/recursion/"},{"categories":["Data Structure and Algorithm"],"content":"Design elements of Recursive Algorithm Explicit recursion termination condition; Extract repetitive logic to reduce the scale of the problem; Give the processing method when recursion terminates. ","date":"2023-02-08","objectID":"/en/recursion/:3:0","tags":["Recursion","Algorithm"],"title":"Recursion Algorithm","uri":"/en/recursion/"},{"categories":["Data Structure and Algorithm"],"content":"The cases of Recursive Algorithm ","date":"2023-02-08","objectID":"/en/recursion/:4:0","tags":["Recursion","Algorithm"],"title":"Recursion Algorithm","uri":"/en/recursion/"},{"categories":["Data Structure and Algorithm"],"content":"The Calculation of factorial Factorial is a typical example of recursive algorithm. Factorial formula is n!=n*(n-1)*(n-2)*…*2*1 . For example, factorial(5)=5*4*3*2*1=120. The code for calculating factorial is as follows： int factorial(int n){ if(n==1){//base case return 1; }else{ return n*factorial(n-1); } } The stop position is called the base case. The base case is the lowest position of the recursive program. There is no need to operate at this position, and a result can be returned directly. All recursive programs must have at least one base case, and must ensure that they will eventually reach a certain base case; Otherwise, the program will run forever until it lacks memory or stack space. ","date":"2023-02-08","objectID":"/en/recursion/:4:1","tags":["Recursion","Algorithm"],"title":"Recursion Algorithm","uri":"/en/recursion/"},{"categories":["Data Structure and Algorithm"],"content":"Fibonacci sequence Fibonacci sequence was first used to describe the number of rabbits growing. Mathematically, Fibonacci sequence is defined by recursion. Therefore, Fibonacci sequence recursion program code is as follows： int Fibonacci(int n){ if(n\u003c=1) return n; else return Fibonacci(n-1)+Fibonacci(n-2); } ","date":"2023-02-08","objectID":"/en/recursion/:4:2","tags":["Recursion","Algorithm"],"title":"Recursion Algorithm","uri":"/en/recursion/"},{"categories":["Data Structure and Algorithm"],"content":"Hanoi Tower Hanoi Tower problem is also a classical recursive problem. The problem is described as follows： Figure1 Hanoi Tower Hanoi Tower originates from an ancient Indian legend. When Brahma created the world, he made three diamond pillars, on which 64 gold discs were stacked in order of size from bottom to top. The Brahma ordered the Brahman to rearrange the disc from below on another pillar in order of size. It is also stipulated that cannot put the large disk on the small disk at any time, and only one disk can be moved between three columns at a time. How should we operate? Problem analysis Figure2 Sloution to Honoi Tower If there is only one disk, you do not need to use the C-pillar to move the disk directly from A to B. If there are two disks, you can move disk 2 on disk 1 to C first; Move disc 1 to B; And then move disc 2 to B. This shows that two discs can be moved from A to B with the help of C. If there are three discs, the moving process is shown in Figure 2. According to the conclusion of the two disks, the two disks on disk 1 can be moved from A to B with the help of C; Move disk 1 from A to C, and A becomes empty ; With the help of the A-pillar, move the two discs from B to C. So, the above idea can be extended to the case of n disks. Move n-1 disks on the starting column to the auxiliary column; Move one disk left on the starting column to the target column; Move all the disks on the auxiliary column to the target column. The code of Hanoi Tower is as follows： #include \u003cstdio.h\u003e /*num represents the number of disks. source、target and auxiliary represent the starting column、the target column and the target column.*/ void hanoi(int num, char sou, char tar,char aux) { //Count the number of moves static int i = 1; //If the number of disks is only 1, move directly from the starting column to the target column if (num == 1) { printf(\"No.%d:move from %c to %c\\n\", i, sou, tar); i++; } else { //Call the hanoi () function recursively，Move num-1 discs from the starting column to the auxiliary column hanoi(num - 1, sou, aux, tar); //Move the last large disk remaining on the starting column to the target column printf(\"No.%d:move from %c to %c\\n\", i, sou, tar); i++; //Call the hanoi () function recursively to move the num-1 disk on the auxiliary column to the target column hanoi(num - 1, aux, tar, sou); } } int main() { //Take moving 3 disks as an example, the starting column, target column and auxiliary column are represented by A, B and C respectively hanoi(3, 'A', 'B', 'C'); return 0; } ","date":"2023-02-08","objectID":"/en/recursion/:4:3","tags":["Recursion","Algorithm"],"title":"Recursion Algorithm","uri":"/en/recursion/"},{"categories":["Data Structure and Algorithm"],"content":"Recursion and Loop Recursion Loop repeat To obtain the result, execute the same code block repeatedly; Repeated execution is realized by repeatedly calling yourself as a signal. To obtain the result, execute the same code block repeatedly; Repeat execution is achieved by completing the code block or executing the continue command signal. Termination conditions To ensure termination, recursive functions need to have a baseline condition to stop recursion. To ensure that it can be terminated, the loop must have one or more conditions that can make it terminate, and must ensure that it can meet one of these conditions under certain circumstances. state The current state is passed as a parameter. Update the current state when the cycle is in progress. Recursion has many similarities with loops. The difference is that the recursive function passes the new value as a parameter to the next function call, and rarely modifies the variable. Therefore, it can avoid using updatable variables, and at the same time, it can conduct repetitive and stateful behavior. ","date":"2023-02-08","objectID":"/en/recursion/:5:0","tags":["Recursion","Algorithm"],"title":"Recursion Algorithm","uri":"/en/recursion/"},{"categories":["Data Structure and Algorithm"],"content":"Reference Detailed explanation of recursive algorithm Hanoi Tower problem (divide and conquer+source code+animation demonstration) Recursive algorithm (illustrated) ","date":"2023-02-08","objectID":"/en/recursion/:6:0","tags":["Recursion","Algorithm"],"title":"Recursion Algorithm","uri":"/en/recursion/"},{"categories":["Data Structure and Algorithm"],"content":"Recursive algorithm optimization methods and strategies","date":"2023-02-09","objectID":"/en/recursive-optimization/","tags":["Recursion","Algorithm","Optimization"],"title":"Recursion  Optimization ","uri":"/en/recursive-optimization/"},{"categories":["Data Structure and Algorithm"],"content":"Recursive Algorithm Generally speaking, recursive algorithms are inefficient and easy to cause stack overflow. For a detailed introduction of recursive algorithm, see Recursion Details ","date":"2023-02-09","objectID":"/en/recursive-optimization/:1:0","tags":["Recursion","Algorithm","Optimization"],"title":"Recursion  Optimization ","uri":"/en/recursive-optimization/"},{"categories":["Data Structure and Algorithm"],"content":"Recursive algorithm optimization strategy There are usually two recursive optimization strategies. Optimization of time complexity; Optimization of spatial complexity. This article takes Fibonacci sequence as an example to explain. ","date":"2023-02-09","objectID":"/en/recursive-optimization/:2:0","tags":["Recursion","Algorithm","Optimization"],"title":"Recursion  Optimization ","uri":"/en/recursive-optimization/"},{"categories":["Data Structure and Algorithm"],"content":"Optimization of time complexity It is not difficult to see that when calculating f(n)=f(n-1)+f(n-2), we should first calculate f(n-1) and f(n-2), including f(n-1)=f(n-2)+f(n-3)and f(n-2)=f(n-3)+f(n-4). In the calculation process, f(n-2) is calculated twice. Therefore, there are a lot of redundant calculations in the calculation process of Fibonacci sequence. In order to eliminate the double calculation in the above cases, one idea is to store the intermediate results in the cache so that we can reuse them later without recalculation. This idea is also known as memorization, which is a technology often used with recursion. Therefore, we can use arrays or hash tables to store intermediate calculation results to reduce the number of calculations.(Space for Time) int fibonacci(int n){ if(n \u003c 0) return 0; if(n=0 || n=1) return n; int ret[n]; ret[0] = 0; ret[1] = 1; for(int i=2; i\u003c=n; i++){ ret[i]=ret[i-1]+ret[i-2]; } return ret[n]; } Time complexity is from O(2^n) to O(n). The essence of the optimization algorithm is actually the idea of dynamic programming. ","date":"2023-02-09","objectID":"/en/recursive-optimization/:2:1","tags":["Recursion","Algorithm","Optimization"],"title":"Recursion  Optimization ","uri":"/en/recursive-optimization/"},{"categories":["Data Structure and Algorithm"],"content":"Optimization of spatial complexity Recursive invocations will generate extra space on the system call stack. If the recursive call level is very deep, it is likely to cause stack overflow during program execution. In this case, there is a special recursion called tail recursion, which can control the impact of space overhead caused by recursion. Tail recursion Tail recursion is a special way of recursion. As the name implies, tail recursion is that the recursive call is the last instruction in the recursive function, and there must be only one recursive call in the function. Tail call The function call will form a “call record\"(or “call frame” ) in memory, and save call location and internal variables and other information. If function B is called inside function A, a call record of B will be formed above the call record of A. The call record of B will not disappear until B finishes running and returns the result to A. If function B calls function C internally, there is also a call record stack for C. By analogy, all call records form a “call stack”. Because it is the last step of the function, tail call is not necessary to keep the call record of the outer function. Because the call location, internal variables and other information will not be used, it just replace the call record of the outer function with the call record of the inner function. int fibonacciTail(int n, int acc, int cal){ //acccollect the return value of the last run of the stack, //because the stack space will be reclaimed later. //cal is every recursive calculation. if(n==0) return acc; if(n==1) return cal; retrun fibonacciTail(n-1, cal, acc+cal); } The above function has two additional parameters, one of which acts as an accumulator and records the return value of each previous stack, because the space of the original stack will be covered by the next layer of recursion. Another parameter is the operation of each recursion. Because it is Fibonacci, here is the addition. The calling method of tail recursion is also different from the original one.Because the initial value of Fibonacci is f(0,1,1,2,…), for the following calls, acc is 0 and cal is 1 here. The method called is fibonacciTail(n,0,1). Function rewrite The required parameters after the optimization of tail recursion are not intuitive enough. Therefore, we usually use the following two methods to rewrite. 1.Currying (Convert multi-parameter functions to single-parameter forms) int fibonacciTail(int n, int acc, int cal){ if(n==0) return acc; if(n==1) return cal; retrun fibonacciTail(n-1, cal, acc+cal); } int fibonacci(int n){ return fibonacciTail(n, 0, 1); } 2.Function parameter initialization int fibonacciTail(int n, int acc=0, int cal=1){ if(n==0) return acc; if(n==1) return cal; retrun fibonacciTail(n-1, cal, acc+cal); } ","date":"2023-02-09","objectID":"/en/recursive-optimization/:2:2","tags":["Recursion","Algorithm","Optimization"],"title":"Recursion  Optimization ","uri":"/en/recursive-optimization/"},{"categories":["Data Structure and Algorithm"],"content":"Reference Comprehend recursion Two optimization methods of Recursion How to optimize recursion - Tail Recursion Optimization ","date":"2023-02-09","objectID":"/en/recursive-optimization/:3:0","tags":["Recursion","Algorithm","Optimization"],"title":"Recursion  Optimization ","uri":"/en/recursive-optimization/"},{"categories":null,"content":"The statement about this website","date":"0001-01-01","objectID":"/en/about/","tags":null,"title":"The statement about this website ","uri":"/en/about/"},{"categories":null,"content":"Welcome to visit this site!!! 😉 This site is designed to record and share knowledge for personal blog.😇 Welcome to leave comments at the bottom of these articles, and please follow the corresponding rules.😄 ","date":"0001-01-01","objectID":"/en/about/:1:0","tags":null,"title":"The statement about this website ","uri":"/en/about/"},{"categories":null,"content":"About content description Because the blogger is not knowledgeable enough, there may be some problems in the content of these articles. Please leave a message to point out these problems or contact the blogger.😃 ","date":"0001-01-01","objectID":"/en/about/:1:1","tags":null,"title":"The statement about this website ","uri":"/en/about/"},{"categories":null,"content":"About articles transferred from the Internet Reprinted articles are only for personal collection and sharing of knowledge. In case of infringement, please contact the blogger to delete them. 🙇 ","date":"0001-01-01","objectID":"/en/about/:1:2","tags":null,"title":"The statement about this website ","uri":"/en/about/"}]