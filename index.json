[{"categories":["多线程"],"content":"C++多线程编程","date":"2025-04-22","objectID":"/multhread/","tags":["C++","多线程"],"title":"多线程","uri":"/multhread/"},{"categories":["多线程"],"content":"多线程 ","date":"2025-04-22","objectID":"/multhread/:1:0","tags":["C++","多线程"],"title":"多线程","uri":"/multhread/"},{"categories":["多线程"],"content":"11 ","date":"2025-04-22","objectID":"/multhread/:2:0","tags":["C++","多线程"],"title":"多线程","uri":"/multhread/"},{"categories":["数据结构与算法"],"content":"牛顿法求解方程近似解","date":"2023-11-01","objectID":"/newton-raphson/","tags":["数值分析","算法"],"title":"牛顿迭代法","uri":"/newton-raphson/"},{"categories":["数据结构与算法"],"content":"概述 牛顿迭代法顾名思义是由牛顿提出的一种用于解决方程近似解的方法。本文主要介绍牛顿迭代法的原理及其在求解平方根中的应用。 ","date":"2023-11-01","objectID":"/newton-raphson/:1:0","tags":["数值分析","算法"],"title":"牛顿迭代法","uri":"/newton-raphson/"},{"categories":["数据结构与算法"],"content":"原理 假设方程$f(x)=0$的一个近似解是$x_k$，$f(x)$在$x_k$处的一阶泰勒展开为$f(x)=f(x_k)+f'(x_k)(x-x_k)+o(x)$，则$f(x_k)+f'(x_k)(x-x_k) \\approx f(x)$ 从而得到$f(x_k)+f'(x_k)(x-x_k)=0$，解得一个新的近似解设为$x_{k+1}$,即： \\begin{equation} x_{k+1}=x_k-\\frac{f(x_k)}{f'(x_k)} \\end{equation} 上式即为牛顿迭代公式。 ","date":"2023-11-01","objectID":"/newton-raphson/:2:0","tags":["数值分析","算法"],"title":"牛顿迭代法","uri":"/newton-raphson/"},{"categories":["数据结构与算法"],"content":"求解平方根 设$f(x)=x^2-n=0$，这个方程的解就是$\\sqrt{n}$，根据牛顿迭代公式，我们可以得到如下迭代式： \\begin{equation} x_{k+1}=x_k-\\frac{x_{k}^2-n}{2x_k}=\\frac{x_k+\\frac{n}{x_k}}{2} \\end{equation} 代码如下： double newton_sqrt(double n){ const double eps = 1e-15;//确定精度 double x = 1; while(true){ double nx = (x+n/x)/2; if(abs(nx-x)\u003ceps) break; x=nx; } } 当然，我们也可以通过二分法进行求解。代码如下： double dichotomy_sqrt(double n){ double left=0; double right=max(1,n); while(abs(left-right)\u003e1e-5){ x=(left+right)/2 if(x*x\u003en) right=x; else left=x; } return x; } 其算法复杂度都为$O(log_{2}n)$. ","date":"2023-11-01","objectID":"/newton-raphson/:3:0","tags":["数值分析","算法"],"title":"牛顿迭代法","uri":"/newton-raphson/"},{"categories":["数据结构与算法"],"content":"参考 oi-wiki-牛顿迭代法 牛顿法 ","date":"2023-11-01","objectID":"/newton-raphson/:4:0","tags":["数值分析","算法"],"title":"牛顿迭代法","uri":"/newton-raphson/"},{"categories":["数据结构与算法"],"content":"递归详解","date":"2023-02-08","objectID":"/recursion/","tags":["递归","算法"],"title":"递归算法","uri":"/recursion/"},{"categories":["数据结构与算法"],"content":"概述 递归算法是一种直接或者间接调用自身函数或者方法的算法。简单来说就是程序自身的调用。 递归算法的本质是将问题不断分解为规模缩小的子问题，然后递归调用方法来表示问题的解。 ","date":"2023-02-08","objectID":"/recursion/:1:0","tags":["递归","算法"],"title":"递归算法","uri":"/recursion/"},{"categories":["数据结构与算法"],"content":"递归算法的特点 递归算法可以将复杂问题简单化，使代码更加简洁。 但是，在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。 递归次数过多容易造成栈溢出，运行效率较低，所以一般不提倡用递归算法设计程序。 ","date":"2023-02-08","objectID":"/recursion/:2:0","tags":["递归","算法"],"title":"递归算法","uri":"/recursion/"},{"categories":["数据结构与算法"],"content":"递归算法的设计要素 明确递归终止条件 提取重复逻辑，缩小问题规模 给出递归终止时的处理方式 ","date":"2023-02-08","objectID":"/recursion/:3:0","tags":["递归","算法"],"title":"递归算法","uri":"/recursion/"},{"categories":["数据结构与算法"],"content":"案例分析 ","date":"2023-02-08","objectID":"/recursion/:4:0","tags":["递归","算法"],"title":"递归算法","uri":"/recursion/"},{"categories":["数据结构与算法"],"content":"阶乘计算 阶乘是典型的递归算法示例。阶乘公式是n!=n*(n-1)*(n-2)*…*2*1。 例如5的阶乘是factorial(5)=5*4*3*2*1=120。计算阶乘代码如下： int factorial(int n){ if(n==1){//基线条件(base case) return 1; }else{ return n*factorial(n-1); } } 停止的位置称为基线条件（base case）。 基线条件是递归程序的最底层位置，在此位置时没有必要再进行操作，可以直接返回一个结果。 所有递归程序都必须至少拥有一个基线条件，而且必须确保它们最终会达到某个基线条件； 否则，程序将永远运行下去，直到程序缺少内存或者栈空间。 ","date":"2023-02-08","objectID":"/recursion/:4:1","tags":["递归","算法"],"title":"递归算法","uri":"/recursion/"},{"categories":["数据结构与算法"],"content":"斐波那契数列 斐波纳契数列(Fibonacci Sequence)，最开始用于描述兔子生长的数目时用上了这数列。 从数学上，费波那契数列是以递归的方法来定义： 因此斐波那契数列递归程序代码如下： int Fibonacci(int n){ if(n\u003c=1) return n; else return Fibonacci(n-1)+Fibonacci(n-2); } ","date":"2023-02-08","objectID":"/recursion/:4:2","tags":["递归","算法"],"title":"递归算法","uri":"/recursion/"},{"categories":["数据结构与算法"],"content":"汉诺塔问题 汉诺塔问题也是一个经典递归问题。问题描述如下： 图1 汉诺塔问题 汉诺塔问题是一个经典的问题。汉诺塔（Hanoi Tower），又称河内塔，源于印度一个古老传说。 大梵天创造世界的时候做了三根金刚石柱子，在一根柱子上从下往上按照大小顺序摞着64片黄金圆盘。 大梵天命令婆罗门把圆盘从下面开始按大小顺序重新摆放在另一根柱子上。 并且规定，任何时候，在小圆盘上都不能放大圆盘，且在三根柱子之间一次只能移动一个圆盘。 问应该如何操作？ 问题分析 图2 汉诺塔问题的解决方案 如果只有 1 个圆盘，则不需要利用C柱，直接将盘子从A移动到B。 如果有 2 个圆盘，可以先将圆盘1上的圆盘2移动到C；将圆盘1移动到B；将圆盘2移动到B。这说明了：可以借助C将2个圆盘从A移动到B。 如果有3个圆盘，移动过程如图2所示。根据2个圆盘的结论，可以借助C将圆盘1上的两个圆盘从A移动到B；将盘子1从A移动到C，A变成空柱；借助A柱，将B上的两个圆盘移动到C。 以此类推，上述的思路可以一直扩展到 n 个圆盘的情况。 将起始柱上的 n-1 个圆盘移动到辅助柱上； 将起始柱上遗留的1个圆盘移动到目标柱上； 将辅助柱上的所有圆盘移动到目标柱上。 汉诺塔问题代码如下： #include \u003cstdio.h\u003e //num 表示移动圆盘的数量，source、target、auxiliary 分别表示起始柱、目标柱和辅助柱 void hanoi(int num, char sou, char tar,char aux) { //统计移动次数 static int i = 1; //如果圆盘数量仅有 1 个，则直接从起始柱移动到目标柱 if (num == 1) { printf(\"第%d次:从 %c 移动至 %c\\n\", i, sou, tar); i++; } else { //递归调用 hanoi() 函数，将 num-1 个圆盘从起始柱移动到辅助柱上 hanoi(num - 1, sou, aux, tar); //将起始柱上剩余的最后一个大圆盘移动到目标柱上 printf(\"第%d次:从 %c 移动至 %c\\n\", i, sou, tar); i++; //递归调用 hanoi() 函数，将辅助柱上的 num-1 圆盘移动到目标柱上 hanoi(num - 1, aux, tar, sou); } } int main() { //以移动 3 个圆盘为例，起始柱、目标柱、辅助柱分别用 A、B、C 表示 hanoi(3, 'A', 'B', 'C'); return 0; } ","date":"2023-02-08","objectID":"/recursion/:4:3","tags":["递归","算法"],"title":"递归算法","uri":"/recursion/"},{"categories":["数据结构与算法"],"content":"递归与循环 递归 循环 重复 为了获得结果，反复执行同一代码块；以反复调用自己为信号而实现重复执行。 为了获得结果，反复执行同一代码块；以完成代码块或者执行 continue 命令信号而实现重复执行。 终止条件 为了确保能够终止，递归函数需要有一个基线条件，令函数停止递归。 为了确保能够终止，循环必须要有一个或多个能够使其终止的条件，而且必须保证它能在某种情况下满足这些条件的其中之一。 状态 当前状态作为参数传递。 循环进行时更新当前状态。 递归可以与循环转换，因此递归与循环有许多类似之处。 在函数式编程中，使用递归代替循环。 区别在于递归函数将新值作为参数传递给下一次函数调用，极少修改变量。 因此其可以避免使用可更新变量，同时能够进行重复的、有状态的行为。 ","date":"2023-02-08","objectID":"/recursion/:5:0","tags":["递归","算法"],"title":"递归算法","uri":"/recursion/"},{"categories":["数据结构与算法"],"content":"参考 递归算法详解 汉诺塔问题（分治+源码+动画演示） 全面理解递归 ","date":"2023-02-08","objectID":"/recursion/:6:0","tags":["递归","算法"],"title":"递归算法","uri":"/recursion/"},{"categories":["数据结构与算法"],"content":"递归算法优化方法和策略","date":"2023-02-09","objectID":"/recursive-optimization/","tags":["递归","算法","优化"],"title":"递归优化","uri":"/recursive-optimization/"},{"categories":["数据结构与算法"],"content":"递归算法 通常来说，递归算法的运行效率很低，容易造成栈溢出。有关递归算法的详细介绍见递归详解。 ","date":"2023-02-09","objectID":"/recursive-optimization/:1:0","tags":["递归","算法","优化"],"title":"递归优化","uri":"/recursive-optimization/"},{"categories":["数据结构与算法"],"content":"递归算法优化策略 递归优化策略通常有两种。 时间复杂度的优化； 空间复杂度的优化。 本文以斐波那契数列为例进行讲解。 ","date":"2023-02-09","objectID":"/recursive-optimization/:2:0","tags":["递归","算法","优化"],"title":"递归优化","uri":"/recursive-optimization/"},{"categories":["数据结构与算法"],"content":"时间复杂度的优化 不难看出，在计算f(n)=f(n-1)+f(n-2)时，要先计算f(n-1)和f(n-2),其中 f(n-1)=f(n-2)+f(n-3)，f(n-2)=f(n-3)+f(n-4)。在计算过程中，f(n-2)被计算了两次。 因此在，斐波那契数列的计算过程中存在着大量的冗余计算。 为了消除上述情况中的重复计算，其中一个想法是将中间结果存储在缓存中，以便我们以后可以重用它们，而不需要重新计算。 这个想法也被称为记忆化，这是一种经常与递归一起使用的技术。 因此，我们可以使用数组或者哈希表来存储中间计算结果，以减少计算次数。(空间换时间) int fibonacci(int n){ if(n \u003c 0) return 0; if(n=0 || n=1) return n; int ret[n]; ret[0] = 0; ret[1] = 1; for(int i=2; i\u003c=n; i++){ ret[i]=ret[i-1]+ret[i-2]; } return ret[n]; } 时间复杂度O(2^n)-\u003eO(n)，该优化算法的本质其实是动态规划的思想。 ","date":"2023-02-09","objectID":"/recursive-optimization/:2:1","tags":["递归","算法","优化"],"title":"递归优化","uri":"/recursive-optimization/"},{"categories":["数据结构与算法"],"content":"空间复杂度的优化 递归调用在系统调用栈上会产生额外空间，如果递归调用层级很深，程序执行过程中很可能导致栈溢出。 针对这种情况，有一种称为尾递归的特殊递归，它可以控制递归导致空间开销的影响。 尾递归 尾递归是一种特殊的递归方式。 顾名思义，尾递归就是递归调用为递归函数中的最后一条指令，并且在函数中应该只有一次递归调用。 尾调用 函数调用会在内存形成一个\"调用记录\"，又称\"调用帧\"（call frame），保存调用位置和内部变量等信息。 如果在函数A的内部调用函数B，那么在A的调用记录上方，还会形成一个B的调用记录。 等到B运行结束，将结果返回到A，B的调用记录才会消失。 如果函数B内部还调用函数C，那就还有一个C的调用记录栈。 以此类推，所有的调用记录，就形成一个\"调用栈\"（call stack）。 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用记录， 因为调用位置、内部变量等信息都不会再用到了， 只要直接用内层函数的调用记录，取代外层函数的调用记录就可以了。 int fibonacciTail(int n, int acc, int cal){ //acc充当收集器的左右，收集上一次运行栈的返回值，因为之后栈空间会被回收 //cal是每一次递归的计算 if(n==0) return acc; if(n==1) return cal; retrun fibonacciTail(n-1, cal, acc+cal); } 上面的函数多了2个参数，一个起到收集器（accumulator)的作用，记录每上一次栈的返回值，因为原来栈的空间会被下一层递归覆盖。 还有一个参数就是每次递归的操作了，因为是斐波那契，所以这里是相加。 尾递归的调用方法也与原来的不一样。因为斐波那契的初始值 ( 0，1 ，1，2 ，……)， 所以以下的调用，acc 要用初始值 0，cal 也要用第二位的值这里也是1， 调用的方法就是 fibonacciTail(n, 0, 1）。 函数改写 尾递归函数优化后函数需要的参数不够直观。因此，我们通常使用下面两种方法进行改写。 1.柯里化（currying），将多参数的函数转换成单参数的形式 int fibonacciTail(int n, int acc, int cal){ //acc充当收集器的左右，收集上一次运行栈的返回值，因为之后栈空间会被回收 //cal是每一次递归的计算 if(n==0) return acc; if(n==1) return cal; retrun fibonacciTail(n-1, cal, acc+cal); } int fibonacci(int n){ return fibonacciTail(n, 0, 1); } 2.函数参数初始化 int fibonacciTail(int n, int acc=0, int cal=1){ //acc充当收集器的左右，收集上一次运行栈的返回值，因为之后栈空间会被回收 //cal是每一次递归的计算 if(n==0) return acc; if(n==1) return cal; retrun fibonacciTail(n-1, cal, acc+cal); } ","date":"2023-02-09","objectID":"/recursive-optimization/:2:2","tags":["递归","算法","优化"],"title":"递归优化","uri":"/recursive-optimization/"},{"categories":["数据结构与算法"],"content":"参考 全面理解递归 递归（Recursion）的两种优化方法 递归如何优化-尾递归优化 ","date":"2023-02-09","objectID":"/recursive-optimization/:3:0","tags":["递归","算法","优化"],"title":"递归优化","uri":"/recursive-optimization/"},{"categories":null,"content":"关于本站声明","date":"0001-01-01","objectID":"/about/","tags":null,"title":"关于本站声明","uri":"/about/"},{"categories":null,"content":"欢迎访问本站点！！！ 😉 该站点为个人博客记录和分享知识。😇 欢迎各位在文章下方进行留言评论，同时请遵守相应规则。😄 ","date":"0001-01-01","objectID":"/about/:1:0","tags":null,"title":"关于本站声明","uri":"/about/"},{"categories":null,"content":"关于内容说明 由于博主才识疏浅，文章内容可能存在一定的问题，欢迎留言指出或联系博主。😃 ","date":"0001-01-01","objectID":"/about/:1:1","tags":null,"title":"关于本站声明","uri":"/about/"},{"categories":null,"content":"关于转载文章说明 转载文章仅为个人收藏，分享知识，如有侵权，请联系博主进行删除。🙇 ","date":"0001-01-01","objectID":"/about/:1:2","tags":null,"title":"关于本站声明","uri":"/about/"}]